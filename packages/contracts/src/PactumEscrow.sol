// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

/**
 * @title PactumEscrow
 * @notice USDC escrow for Pactum agent marketplace
 * @dev Flow: buyer deposit → 1-day confirm window → operator release (minus fee) or refund
 *
 *  Actors:
 *   - buyer:    deposits USDC, can confirm or dispute within CONFIRM_WINDOW
 *   - seller:   registered wallet that receives payment on release
 *   - operator: platform backend wallet, can release/refund/resolve disputes
 *   - owner:    can update operator, feeBps, feeRecipient
 */
contract PactumEscrow is ReentrancyGuard {
    using SafeERC20 for IERC20;

    // ----------------------------------------------------------------
    // Constants & config
    // ----------------------------------------------------------------

    IERC20 public immutable usdc;

    uint256 public constant CONFIRM_WINDOW = 1 days;
    uint256 public constant MAX_FEE_BPS = 1000; // 10% hard cap

    address public owner;
    address public operator;
    address public feeRecipient;
    uint256 public feeBps; // e.g. 250 = 2.5%

    uint256 public accumulatedFees;

    // ----------------------------------------------------------------
    // Order
    // ----------------------------------------------------------------

    enum Status {
        Pending,   // funds locked, waiting for confirm window
        Released,  // funds sent to seller (minus fee)
        Refunded,  // funds returned to buyer
        Disputed   // buyer raised dispute, waiting for operator resolution
    }

    struct Order {
        address buyer;
        address seller;
        uint256 amount;       // USDC amount (6 decimals)
        uint256 depositedAt;  // timestamp of deposit
        Status status;
    }

    mapping(bytes32 => Order) public orders;

    // ----------------------------------------------------------------
    // Events
    // ----------------------------------------------------------------

    event Deposited(bytes32 indexed orderId, address indexed buyer, address indexed seller, uint256 amount);
    event Confirmed(bytes32 indexed orderId, address indexed confirmedBy); // buyer or auto
    event Disputed(bytes32 indexed orderId, address indexed buyer);
    event Released(bytes32 indexed orderId, address indexed seller, uint256 sellerAmount, uint256 fee);
    event Refunded(bytes32 indexed orderId, address indexed buyer, uint256 amount);
    event FeesWithdrawn(address indexed to, uint256 amount);
    event OperatorUpdated(address indexed oldOperator, address indexed newOperator);
    event FeeUpdated(uint256 oldFeeBps, uint256 newFeeBps);

    // ----------------------------------------------------------------
    // Errors
    // ----------------------------------------------------------------

    error NotOwner();
    error NotOperator();
    error NotBuyer();
    error OrderNotFound();
    error OrderNotPending();
    error OrderNotDisputed();
    error ConfirmWindowOpen();
    error ConfirmWindowClosed();
    error InvalidSeller();
    error ZeroAmount();
    error FeeTooHigh();
    error NoFeesToWithdraw();

    // ----------------------------------------------------------------
    // Modifiers
    // ----------------------------------------------------------------

    modifier onlyOwner() {
        if (msg.sender != owner) revert NotOwner();
        _;
    }

    modifier onlyOperator() {
        if (msg.sender != operator) revert NotOperator();
        _;
    }

    // ----------------------------------------------------------------
    // Constructor
    // ----------------------------------------------------------------

    constructor(
        address _usdc,
        address _operator,
        address _feeRecipient,
        uint256 _feeBps
    ) {
        if (_feeBps > MAX_FEE_BPS) revert FeeTooHigh();
        usdc = IERC20(_usdc);
        owner = msg.sender;
        operator = _operator;
        feeRecipient = _feeRecipient;
        feeBps = _feeBps;
    }

    // ----------------------------------------------------------------
    // Buyer actions
    // ----------------------------------------------------------------

    /**
     * @notice Buyer deposits USDC into escrow for a given order.
     * @param orderId  Unique order ID generated by the platform backend.
     * @param seller   Registered seller wallet address.
     * @param amount   USDC amount (6 decimals). Must pre-approve this contract.
     */
    function deposit(bytes32 orderId, address seller, uint256 amount) external nonReentrant {
        if (amount == 0) revert ZeroAmount();
        if (seller == address(0) || seller == msg.sender) revert InvalidSeller();
        if (orders[orderId].buyer != address(0)) revert OrderNotFound(); // already exists

        usdc.safeTransferFrom(msg.sender, address(this), amount);

        orders[orderId] = Order({
            buyer: msg.sender,
            seller: seller,
            amount: amount,
            depositedAt: block.timestamp,
            status: Status.Pending
        });

        emit Deposited(orderId, msg.sender, seller, amount);
    }

    /**
     * @notice Buyer manually confirms delivery before the window expires.
     *         Triggers immediate release to seller.
     * @param orderId  The order to confirm.
     */
    function confirm(bytes32 orderId) external nonReentrant {
        Order storage o = orders[orderId];
        if (o.buyer == address(0)) revert OrderNotFound();
        if (o.status != Status.Pending) revert OrderNotPending();
        if (msg.sender != o.buyer) revert NotBuyer();

        emit Confirmed(orderId, msg.sender);
        _release(orderId, o);
    }

    /**
     * @notice Buyer raises a dispute within the confirm window.
     *         Freezes the order; operator must resolve.
     * @param orderId  The order to dispute.
     */
    function dispute(bytes32 orderId) external {
        Order storage o = orders[orderId];
        if (o.buyer == address(0)) revert OrderNotFound();
        if (o.status != Status.Pending) revert OrderNotPending();
        if (msg.sender != o.buyer) revert NotBuyer();
        if (block.timestamp >= o.depositedAt + CONFIRM_WINDOW) revert ConfirmWindowClosed();

        o.status = Status.Disputed;
        emit Disputed(orderId, msg.sender);
    }

    // ----------------------------------------------------------------
    // Operator actions
    // ----------------------------------------------------------------

    /**
     * @notice Auto-confirm after window expires (callable by anyone, typically operator cron).
     *         If buyer neither confirmed nor disputed within 1 day, funds go to seller.
     * @param orderId  The order to auto-confirm.
     */
    function autoConfirm(bytes32 orderId) external nonReentrant {
        Order storage o = orders[orderId];
        if (o.buyer == address(0)) revert OrderNotFound();
        if (o.status != Status.Pending) revert OrderNotPending();
        if (block.timestamp < o.depositedAt + CONFIRM_WINDOW) revert ConfirmWindowOpen();

        emit Confirmed(orderId, address(0)); // address(0) = auto
        _release(orderId, o);
    }

    /**
     * @notice Operator resolves a disputed order in favor of the seller.
     * @param orderId  The disputed order to release.
     */
    function resolveRelease(bytes32 orderId) external nonReentrant onlyOperator {
        Order storage o = orders[orderId];
        if (o.buyer == address(0)) revert OrderNotFound();
        if (o.status != Status.Disputed) revert OrderNotDisputed();

        _release(orderId, o);
    }

    /**
     * @notice Operator resolves a disputed order in favor of the buyer (refund).
     * @param orderId  The disputed order to refund.
     */
    function resolveRefund(bytes32 orderId) external nonReentrant onlyOperator {
        Order storage o = orders[orderId];
        if (o.buyer == address(0)) revert OrderNotFound();
        if (o.status != Status.Disputed) revert OrderNotDisputed();

        _refund(orderId, o);
    }

    /**
     * @notice Operator emergency refund for a pending order (e.g. seller failed to deliver).
     * @param orderId  The pending order to refund.
     */
    function emergencyRefund(bytes32 orderId) external nonReentrant onlyOperator {
        Order storage o = orders[orderId];
        if (o.buyer == address(0)) revert OrderNotFound();
        if (o.status != Status.Pending) revert OrderNotPending();

        _refund(orderId, o);
    }

    /**
     * @notice Withdraw accumulated platform fees to feeRecipient.
     */
    function withdrawFees() external onlyOperator {
        uint256 amount = accumulatedFees;
        if (amount == 0) revert NoFeesToWithdraw();
        accumulatedFees = 0;
        usdc.safeTransfer(feeRecipient, amount);
        emit FeesWithdrawn(feeRecipient, amount);
    }

    // ----------------------------------------------------------------
    // Owner config
    // ----------------------------------------------------------------

    function setOperator(address _operator) external onlyOwner {
        emit OperatorUpdated(operator, _operator);
        operator = _operator;
    }

    function setFeeRecipient(address _feeRecipient) external onlyOwner {
        feeRecipient = _feeRecipient;
    }

    function setFeeBps(uint256 _feeBps) external onlyOwner {
        if (_feeBps > MAX_FEE_BPS) revert FeeTooHigh();
        emit FeeUpdated(feeBps, _feeBps);
        feeBps = _feeBps;
    }

    function transferOwnership(address _newOwner) external onlyOwner {
        owner = _newOwner;
    }

    // ----------------------------------------------------------------
    // View
    // ----------------------------------------------------------------

    function getOrder(bytes32 orderId) external view returns (Order memory) {
        return orders[orderId];
    }

    function isConfirmable(bytes32 orderId) external view returns (bool) {
        Order storage o = orders[orderId];
        return o.status == Status.Pending && block.timestamp >= o.depositedAt + CONFIRM_WINDOW;
    }

    // ----------------------------------------------------------------
    // Internal
    // ----------------------------------------------------------------

    function _release(bytes32 orderId, Order storage o) internal {
        o.status = Status.Released;

        uint256 fee = (o.amount * feeBps) / 10000;
        uint256 sellerAmount = o.amount - fee;

        accumulatedFees += fee;
        usdc.safeTransfer(o.seller, sellerAmount);

        emit Released(orderId, o.seller, sellerAmount, fee);
    }

    function _refund(bytes32 orderId, Order storage o) internal {
        o.status = Status.Refunded;
        usdc.safeTransfer(o.buyer, o.amount);
        emit Refunded(orderId, o.buyer, o.amount);
    }
}
